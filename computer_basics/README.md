# 计算机基础知识

## 操作系统

### 线程和进程、协程

协程是属于线程的。协程程序是在线程里面跑的，协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程。
原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。
在Python中，使用了yield的函数为生成器函数，即可以多次返回值。则生成器可以暂停一下，转而执行其他代码，再回来继续执行函数往下的代码。

### 协程和线程比优势在哪？什么情况下用线程，什么时候用协程

### 进程/线程/协程间通信

进程通信目的：数据传输，共享数据，资源共享，进程控制
进程间需要：管道，FIFO命名管道，消息队列，共享存储通信达到进程同步的目的。
线程间用好锁就行了，共享存储空间和变量资源。
协成间是同一线程，共享的数据。

### 进程的几个状态
创建，就绪，等待，运行，结束。就绪和运行之间可以相互转换。

### 一个进程里包含什么？
一个进程由三部分组成：程序、数据及进程控制块(PCB)。进程控制块是记录进程有关信息的一块主存，是进程存在的程序唯一标识。

### 自旋锁和互斥锁

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。
线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。
互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。

### 死锁以及预防

## Linux

### 常用命令

kill mkdir pip cd cp unzip

### 查看内存使用情况

top命令展示所有进程的信息： PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行  NI：进程Nice值，代表这个进程的优先值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存

top -p pid 查看指定程序的情况

命令：free 用KB为单位展示数据；free -m    用MB为单位展示数据；free -h     用GB为单位展示数据；total : 总计屋里内存的大小 used : 已使用内存的大小 free : 可用内存的大小

ps aux按照该pid显示内容 ps -aux | grep process_name

### 

## 计算机网络

### TCP三次握手

A 为客户端，B 为服务器端

首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。

B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。

A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。

B 收到 A 的确认后，连接建立。

是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

### TCP四次挥手

A 发送连接释放报文，FIN=1。

B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

当 B 不再需要连接时，发送连接释放报文，FIN=1。

A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

B 收到 A 的确认后释放连接。

原因：

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，
传送完毕之后，服务器会发送 FIN 连接释放报文。

### 四次挥手 TIME_WAIT原因，MSL是什么？为什么要等待2MSL？

报文最大生存时间 MSL，A客户端，B服务端
确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

报文最大生存时间

### udp和tcp区别


TCP面向连接（如打电话要先拨号建立连接） UDP是无连接的，即发送数据之前不需要建立连接

TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

TCP首部开销20字节;UDP的首部开销小，只有8个字节

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

用户数据报协议 UDP（User Datagram Protocol）是无连接的，
尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，
把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

### HTTPS

### 打开浏览器访问网址发生了什么

## python

### python动态解释

解释型语言，编译型语言。python是解释，在解释器中运行。编译是翻译成机器码。

### Python为什么会慢？

答：因为不知道数据类型，取数据要判断一下

1、python是一个动态的解释型语言；python中的值不是存储在缓存区而是分散的存储在对象中
2、Python是一门解释器语言，和C++，java不同，C++，java都是编译语言，也就是说写完Java程序首先要编译源程序，生成可执行文件一个class文件，
而Python写完程序，提交到解释器，解释器会立刻将第一行代码翻译成机器码，然后将这行代码交给CPU去执行，然后进行下一行，翻译第二行代码，
再交给CPU执行，所以，Python要比那些编译型语言执行起来要慢

### GIL解释器，线程进程，协程

因为CPython解释器是大部分环境下默认的Python执行环境，GIL是实现解析器(CPython)时所引入的一个概念
全局解释器锁（GIL）不能真正的并行，只能并发。多线程对IO密集型操作效果好，对CPU密集型操作效果差。 CPU密集用进程，IO密集用线程。

协程看上去像子程序，例如AB两个子程序，A执行一般暂停，B执行，B执行完A在继续执行。
优点：1执行效率高，没有线程切换的开销（切换由程序本身控制）
2共享资源不需要锁，因为只有一个线程。  为了利用多核CPU，多进程+协成可以利用多核高效。

### 线程同步

使用Lock函数，acquire 和 release获得和释放锁。

### 什么是内存泄露？什么时候会内存泄露？python垃圾回收机制

没有删掉。（动态申请的内存空间没有被正常释放，但也不能继续被使用的情况。没有释放内存）
python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。分代回收：0，1，2年轻，中年，老年三代，清理年轻代，剩下到中年，以此类推
标记-清除：先标记活动的，后清除不活动的，图实现（对象之间通过引用（指针）连在一起），可到达的就是活动，不可达的清除

### python中函数self

类实例化后，实例中的属性值都在self中。通过self调用实例中其他的方法和变量。类似java中的this

### 迭代器和生成器

凡是可以返回一个迭代器的对象都可称之为可迭代对象，__iter__和__next__
调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，

所有生成器都是迭代器，生成器函数会创建一个生成器对象，生成器只有当需要下一个结果的时候才会计算。

### 装饰器

装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。
有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

### __new__和__init__

new是先调用创建实例，传入cls参数，init后面初始化用。传入self第一个变量

### import与 from A import B 的区别

rom A import B在导入过程中 创建模块对象 将模块对象的引用保存在本地作用域, 也就是说当前作用域有一个名字叫B的对象,locals()可以查看; 
import A 在导入模块的过程 创建模块对象 将模块对象的引用保存在本地

### is 和 ==区别

万物皆对象，is判断id是否相等，==判断值是否相等。

### 深拷贝和浅拷贝

copy和deepcopy，如果有指针到子对象，浅只拷贝指针地址，深拷贝会生成新的指针地址（生成新的变量）

### dict字典的底层数据结构

是通过哈希表来实现的，对key（不可变的变量）做哈希函数，然后对N（哈希表长度）取模得到位置存放这个数据。（可以是链表这里，因为有的哈希值结果取模后可能一样）
当N快要满的时候进行扩容，java和python都可以离线扩容（不用的时候扩容），这样不会影响使用时候的时间复杂度。
使用开放寻址法解决冲突，数组中1/3的位置为空, 增加元素可能会导致扩容, 引发新的散列冲突, 导致新的散列表中键的次序发生变化, 这也是字典遍历时不能添加和删除的原因

### 哈希冲突的解决办法

1使用单链表解决，相同值存在链表下一个节点。遍历链表找。java中使用的，1.8之后链表长度大于8增加了红黑树

2开放定址法：线行探查法、平方探查法、双散列函数探查法。缺点：删除元素的时候不能真的删除，会引起查找错误，只能做一个特殊标记。下个元素插入才能真正删除该元素。

## java

## 面向对象

## 数据库

### [范式](https://zhuanlan.zhihu.com/p/63146817)

1NF 属性不可分，确保每列保持原子性（地址中拆分出城市）

2NF 每个非主属性完全函数依赖于键码。可以通过分解来满足。(确保表中的每列都和主键相关)
一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

3NF 非主属性不传递函数依赖于键码。(确保每列都和主键列直接相关,而不是间接相关)

### 事务

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
原子性（Atomicity）一致性（Consistency）隔离性（Isolation）一个事务最终提交前，其他事务不可见。持久性（Durability）


### 存储过程

### 红黑树

### B+树

### mysql的哈希索引和B+树索引

哈希无序，无法排序和模糊查找。

### sybase IQ列式数据库和行式数据库区别

## 工具(git, docker, 正则表达式等)

### git常用命令

### git如何多人合作

西欧fast开发实践

### 什么是微服务

是一种软件架构风格，将软件设计为一组小型服务的方法，它是以专注于单一责任与功能的小型功能区块为基础，
利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信。
每个服务都在自己的进程中运行并进行通信。

### Docker原理

使用Linux的namespace（类似于JAVA的命名空间）和cgroup（controll （system resource） （for） （process）groups），

namespace提供一种资源隔离方案（运行环境隔离），不同用户看不到其他用户资源。没给ns都有init进程(PID为0)（像一台单独的Linux）

cgroup用控制使用系统资源，防止占用过多，可以为ns分配资源

### docker简单命令

从镜像库拉去pull镜像，获得rabbimq。run启动，后面start/stop/restart，控制容器生命周期。rm删除容器。ps显示容器状态（-a显示所有），logs查询日志。

本地镜像管理：build创建（根据dockerfile）rmi删除镜像，images显示本地所有镜像。history展示镜像创建历史。


## 基于微服务的自动防御相关内容

### 项目介绍

项目包括CA（control app）控制系统 和 IDS (Intrusion Detection System) 入侵检测系统。
控制系统包括3个微服务，IDS我开发了3个微服务，并且对后续微服务需要的消息做了发布。
整个项目使用了7个docker 容器，部署了包括6个微服务和rabbitmq消息队列。还有一个模拟工厂水罐传感器信号的并发py脚本。传递实时水位情况。

### 为啥用nameko

目前python下面主要都是web框架。是基于微服务架构理念的一个开源框架，框架的目的是让开发者更多的聚焦在业务逻辑和功能的实现上，而底层的通信机制则由框架本身来解决。
Django和Flask都是web后端，相比较这些框架提供的功能更多，但是使用也更复杂。

### nameko框架讲一下

基于AMQP的RPC方式；
基于AMQP的异步事件发布-订阅；我使用的方式
简单的HTTP请求，GET和POST；
使用nameko需要使用RabbitMQ消息代理

### 为什么用rabbitmq（如何选择消息队列）对比不同消息队列

Kafka是基于一套自己定义TCP协议的。由于选择了nameko使用AMQP协议，所以选择rabbitmq用做消息队列。开源提供的管理界面非常棒，用起来很好用
性能较好，高并发；吞吐量到万级，MQ功能比较完备。健壮、稳定、易用、跨平台、支持多种语言、文档齐全；

### [rabbitmq保重不重复消费](https://blog.csdn.net/n950814abc/article/details/98320046) [面试题](https://juejin.im/post/6844903997489446919)

### RabbitMQ可靠性传输的实现 （发送方，broker ， 接收方）三方；消息幂等性实现（用户发起多次重复请求保持结果和一次请求一致）

幂等性，通俗点说，，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。

给传感器信号打时间戳不会重复消费传感器数据，如果连续传输2个传感器信号可能一样，打了不同时间戳对于控制系统并没有影响，控制系统计算出的操作是一致的。

结合业务思考如何实现：比如写入数据库，根据主键检查，有了就只更新不插入。如果写redis（是set）直接写就行。生产者生产时候加上id，消费者拿到id去hash表查下是否有。
如果消费过就不处理了。

### AMQP协议底层

高级消息队列协议（Advanced Message Queuing Protocol）
是面向消息中间件提供的开放的应用层协议，其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性。
AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样。
与先前的中间件标准（如Java消息服务）不同的是，JMS在特定的API接口层面和实现行为上进行了统一，而高级消息队列协议则关注于各种消息如何以字节流的形式进行传递。
因此，使用了符合协议实现的任意应用程序之间可以保持对消息的创建、传递。

## [面试所有资料](https://github.com/CyC2018/CS-Notes)
