# 计算机基础知识

## 操作系统

### 线程和进程、协程

### 进程/线程/协程间通信

进程间需要：管道，FIFO命名管道，消息队列，共享存储通信达到进程同步的目的。
线程间用好锁就行了，共享存储空间和变量资源。
协成间是同一线程，共享的数据。

### 进程的几个状态
创建，就绪，等待，运行，结束。就绪和运行之间可以相互转换。

### 自旋锁和互斥锁

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。
线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。
互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。

## 计算机网络

### TCP三次握手

A 为客户端，B 为服务器端

首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。

B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。

A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。

B 收到 A 的确认后，连接建立。

是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

### TCP四次挥手

A 发送连接释放报文，FIN=1。

B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

当 B 不再需要连接时，发送连接释放报文，FIN=1。

A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

B 收到 A 的确认后释放连接。

原因：

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，
传送完毕之后，服务器会发送 FIN 连接释放报文。

### 四次挥手 TIME_WAIT原因

确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。

等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。


### udp和tcp区别

用户数据报协议 UDP（User Datagram Protocol）是无连接的，
尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，
把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

### HTTPS

### 打开浏览器访问网址发生了什么

## python

### python动态解释

解释型语言，编译型语言。python是解释，在解释器中运行。编译是翻译成机器码。

### Python为什么会慢？

答：因为不知道数据类型，取数据要判断一下

1、python是一个动态的解释型语言；python中的值不是存储在缓存区而是分散的存储在对象中
2、Python是一门解释器语言，和C++，java不同，C++，java都是编译语言，也就是说写完Java程序首先要编译源程序，生成可执行文件一个class文件，
而Python写完程序，提交到解释器，解释器会立刻将第一行代码翻译成机器码，然后将这行代码交给CPU去执行，然后进行下一行，翻译第二行代码，
再交给CPU执行，所以，Python要比那些编译型语言执行起来要慢

### GIL解释器，线程进程，协程

因为CPython是大部分环境下默认的Python执行环境，GIL是实现解析器(CPython)时所引入的一个概念
全局解释器锁（GIL）不能真正的并行，只能并发。多线程对IO密集型操作效果好，对CPU密集型操作效果差。 CPU密集用进程，IO密集用线程。

协程看上去像子程序，例如AB两个子程序，A执行一般暂停，B执行，B执行完A在继续执行。
优点：1执行效率高，没有线程切换的开销（切换由程序本身控制）
2共享资源不需要锁，因为只有一个线程。  为了利用多核CPU，多进程+协成可以利用多核高效。

### 线程同步

使用Lock函数，acquire 和 release获得和释放锁。

### 什么是内存泄露？什么时候会内存泄露？python垃圾回收机制

没有删掉。（动态申请的内存空间没有被正常释放，但也不能继续被使用的情况。没有释放内存）
python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。分代回收：0，1，2年轻，中年，老年三代，清理年轻代，剩下到中年，以此类推
标记-清除：先标记活动的，后清除不活动的，图实现（对象之间通过引用（指针）连在一起），可到达的就是活动，不可达的清除

### python中函数self

类实例化后，实例中的属性值都在self中。通过self调用实例中其他的方法和变量。类似java中的this

### 迭代器和生成器

凡是可以返回一个迭代器的对象都可称之为可迭代对象，__iter__和__next__
调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，

所有生成器都是迭代器，生成器函数会创建一个生成器对象，生成器只有当需要下一个结果的时候才会计算。

### 装饰器

装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。
有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

### __new__和__init__

new是先调用创建实例，传入cls参数，init后面初始化用。传入self第一个变量

### import与 from A import B 的区别

rom A import B在导入过程中 创建模块对象 将模块对象的引用保存在本地作用域, 也就是说当前作用域有一个名字叫B的对象,locals()可以查看; 
import A 在导入模块的过程 创建模块对象 将模块对象的引用保存在本地

### is 和 ==区别

万物皆对象，is判断id是否相等，==判断值是否相等。

### 深拷贝和浅拷贝

copy和deepcopy，如果有指针到子对象，浅只拷贝指针地址，深拷贝会生成新的指针地址（生成新的变量）

## java

## 面向对象

## 数据库

### sybase IQ列式数据库

## 工具(git, docker, 正则表达式等)

### 微服务

### Docker原理

### 基于微服务的自动防御相关内容

## [面试所有资料](https://github.com/CyC2018/CS-Notes)

## [jvm相关，网络知识(TCP/IP,DNS)](https://www.nowcoder.com/discuss/392327?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post)
