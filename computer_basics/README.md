# 计算机基础知识

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `操作系统`

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `字节，M，G换算，如何读取数据到内存`

8bit = 1字节 1024字节bytes = 1KB 	1024KB = 1MB	1024MB = 1GB


### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `线程和进程、协程`

协程是属于线程的。协程程序是在线程里面跑的，协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程。
原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。
在Python中，使用了yield的函数为生成器函数，即可以多次返回值。则生成器可以暂停一下，转而执行其他代码，再回来继续执行函数往下的代码。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `协程和线程比优势在哪？什么情况下用线程，什么时候用协程`

协程效率比线程高，不需要切换线程，由程序自身控制。线程不需要锁，只需要判断状态。更轻量级。
IO密集型一般使用多线程或者多进程，CPU密集型一般使用多进程，强调非阻塞异步并发的一般都是使用协程

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `进程/线程/协程间通信`

进程通信目的：数据传输，共享数据，资源共享，进程控制
进程间需要：管道，FIFO命名管道，消息队列，共享存储通信达到进程同步的目的。
线程间用好锁就行了，共享存储空间和变量资源。
协成间是同一线程，共享的数据。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `进程的几个状态`
创建，就绪，等待，运行，结束。就绪和运行之间可以相互转换。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `一个进程里包含什么？`
一个进程由三部分组成：程序、数据及进程控制块(PCB)。进程控制块是记录进程有关信息的一块主存，是进程存在的程序唯一标识。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `自旋锁和互斥锁`

自旋锁是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。
线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。
互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `死锁以及预防的四种处理方式`

鸵鸟策略：发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。解决死锁问题的代价很高，该策略性能高。

死锁检测与死锁恢复：当检测到死锁发生时，采取措施进行恢复。利用抢占恢复，利用回滚恢复，通过杀死进程恢复

死锁预防：在程序运行之前预防发生死锁。1. 破坏互斥条件。2. 破坏占有和等待条件。3. 破坏不可抢占条件。4. 破坏环路等待

死锁避免：在程序运行时避免发生死锁。

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `Linux`

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `常用命令`

ls -al 显示所有文件（目录下包括隐藏文件） mkdir创建文件夹 cat查看文件内容 cp拷贝 rm -rf 删除文件（夹）下所有文件 
find 查找文件 grep 正则匹配 pwd显示当前文件路径 chmod修改文件权限 netstat -a|grep 查看网络状态 top展示进程信息 unzip解压缩 
kill -9 pid强行杀死进程

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `查看内存使用情况`

top命令展示所有进程的信息： PID：进程的ID USER：进程所有者 PR：进程的优先级别，越小越优先被执行  NI：进程Nice值，代表这个进程的优先值 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存

top -p pid 查看指定程序的情况

命令：free 用KB为单位展示数据；free -m    用MB为单位展示数据；free -h     用GB为单位展示数据；total : 总计屋里内存的大小 used : 已使用内存的大小 free : 可用内存的大小

ps aux按照该pid显示内容 ps -aux | grep process_name  ps -e查看所有进程信息 

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `Linux IO模型（5种）`

IO通常包括2个阶段：1等待数据准备好（通常涉及等待数据从网络中到达，复制到内核中的缓冲区）。2从内核向进程复制数据（从内核缓冲区复制到应用进程缓冲区）

阻塞式 I/O	进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回，阻塞的过程中，其它应用进程还可以执行

非阻塞式 I/O	应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，
这种方式称为轮询（polling）。

I/O 复用（select 和 poll）	使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。
这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。让单个进程具有处理多个 I/O 事件的能力

信号驱动式 I/O（SIGIO）	内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。
相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。

异步 I/O（AIO）应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。

同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `epoll和select、poll区别`

select和poll都是线性轮询，select 和 poll 速度都比较慢，几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。
poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。select 会修改描述符，而 poll 不会；

epoll 是回调callback，只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。已注册的描述符在内核中会被维护在一棵红黑树上，
通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。
仅适用于 Linux OS。比 select 和 poll 更加灵活而且没有描述符数量限制。对多线程编程更有友好。

select适用于微秒级高精度的（核反应控制）poll没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。

epoll适用于有大量的描述符（同时监控大于 1000 个描述符）需要同时轮询，并且这些连接最好是长连接。

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `计算机网络`

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `TCP三次握手`

A 为客户端，B 为服务器端

首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。

A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。

B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。

A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。

B 收到 A 的确认后，连接建立。

是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `TCP四次挥手`

A 发送连接释放报文，FIN=1。

B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。

当 B 不再需要连接时，发送连接释放报文，FIN=1。

A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。

B 收到 A 的确认后释放连接。

原因：

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，
传送完毕之后，服务器会发送 FIN 连接释放报文。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `四次挥手 TIME_WAIT原因，MSL是什么？为什么要等待2MSL？`

报文最大生存时间 MSL，A客户端，B服务端
确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

报文最大生存时间

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `udp和tcp区别`

TCP面向连接（如打电话要先拨号建立连接） UDP是无连接的，即发送数据之前不需要建立连接

TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

TCP首部开销20字节;UDP的首部开销小，只有8个字节

TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

用户数据报协议 UDP（User Datagram Protocol）是无连接的，
尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，
把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `TCP滑动窗口`

窗口是缓存的一部分，用来暂时存放字节流，是用来改善吞吐量的一种技术。发送方和接收方各有一个窗口，
接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，
发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。发送左边确认接受就窗口右移动，接受左边确认发送确认并交付主机就有移动

接收窗口只会对窗口内最后一个按序到达的字节进行确认

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `TCP流量控制`

控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `TCP拥塞控制`

1慢开始、拥塞避免.2快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `http报文组成`

开始行、首部行、实体主体。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `HTTP报文头部`

请求：get（请求 方法、URL、HTTP版本）host主机,accept，language，encode,user agent，content length

响应：status（HTTP 版本和状态码），date，server（服务器），last modified，E tag，accept ranges，content length，connection，content type

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `HTTP状态码`

1XX 信息（接收的请求正在处理）	2XX 成功（请求正常处理完毕）	3XX 重定向（需要进行附加操作以完成请求）	
4XX 客户端错误（服务器无法处理请求）	5XX 服务器错误(服务器处理请求出错)

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `HTTP协议有哪些方法`

get获取资源post用来传输数据

GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。
不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。

安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，会改变服务器状态。
安全的方法除了 GET 之外还有：HEAD、OPTIONS。
不安全的方法除了 POST 之外还有 PUT、DELETE。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `打开浏览器访问网址发生了什么`

DNS 解析:将域名解析成 IP 地址 

TCP 连接：TCP 三次握手 

发送 HTTP 请求 

服务器处理请求并返回 HTTP 报文 

浏览器解析渲染页面 

断开连接：TCP 四次挥手 

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `ARP协议，为什么会有ARP转换`

地址解析协议，网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。
因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。ARP 实现由 IP 地址得到 MAC 地址。

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `python`

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `python动态解释`

解释型语言，编译型语言。python是解释，在解释器中运行。编译是翻译成机器码。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `Python为什么会慢？`

答：因为不知道数据类型，取数据要判断一下

1、python是一个动态的解释型语言；python中的值不是存储在缓存区而是分散的存储在对象中
2、Python是一门解释器语言，和C++，java不同，C++，java都是编译语言，也就是说写完Java程序首先要编译源程序，生成可执行文件一个class文件，
而Python写完程序，提交到解释器，解释器会立刻将第一行代码翻译成机器码，然后将这行代码交给CPU去执行，然后进行下一行，翻译第二行代码，
再交给CPU执行，所以，Python要比那些编译型语言执行起来要慢

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `GIL解释器，线程进程，协程`

因为CPython解释器是大部分环境下默认的Python执行环境，GIL是实现解析器(CPython)时所引入的一个概念
全局解释器锁（GIL）不能真正的并行，只能并发。多线程对IO密集型操作效果好，对CPU密集型操作效果差。 CPU密集用进程，IO密集用线程。

协程看上去像子程序，例如AB两个子程序，A执行一般暂停，B执行，B执行完A在继续执行。
优点：1执行效率高，没有线程切换的开销（切换由程序本身控制）
2共享资源不需要锁，因为只有一个线程。  为了利用多核CPU，多进程+协成可以利用多核高效。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `线程同步`

使用Lock函数，acquire 和 release获得和释放锁。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `什么是内存泄露？什么时候会内存泄露？python垃圾回收机制`

没有删掉。（动态申请的内存空间没有被正常释放，但也不能继续被使用的情况。没有释放内存）
python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。分代回收：0，1，2年轻，中年，老年三代，清理年轻代，剩下到中年，以此类推
标记-清除：先标记活动的，后清除不活动的，图实现（对象之间通过引用（指针）连在一起），可到达的就是活动，不可达的清除

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `python中函数self`

类实例化后，实例中的属性值都在self中。通过self调用实例中其他的方法和变量。类似java中的this

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `迭代器和生成器`

凡是可以返回一个迭代器的对象都可称之为可迭代对象，__iter__和__next__
调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，

所有生成器都是迭代器，生成器函数会创建一个生成器对象，生成器只有当需要下一个结果的时候才会计算。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `装饰器`

装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。
有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `__new__和__init__`

new是先调用创建实例，传入cls参数，init后面初始化用。传入self第一个变量

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `import与 from A import B 的区别`

rom A import B在导入过程中 创建模块对象 将模块对象的引用保存在本地作用域, 也就是说当前作用域有一个名字叫B的对象,locals()可以查看; 
import A 在导入模块的过程 创建模块对象 将模块对象的引用保存在本地

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `is 和 ==区别`

万物皆对象，is判断id是否相等，==判断值是否相等。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `深拷贝和浅拷贝`

copy和deepcopy，如果有指针到子对象，浅只拷贝指针地址，深拷贝会生成新的指针地址（生成新的变量）

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `dict字典的底层数据结构`

是通过哈希表来实现的，对key（不可变的变量）做哈希函数，然后对N（哈希表长度）取模得到位置存放这个数据。（可以是链表这里，因为有的哈希值结果取模后可能一样）
当N快要满的时候进行扩容，java和python都可以离线扩容（不用的时候扩容），这样不会影响使用时候的时间复杂度。
使用开放寻址法解决冲突，数组中1/3的位置为空, 增加元素可能会导致扩容, 引发新的散列冲突, 导致新的散列表中键的次序发生变化, 这也是字典遍历时不能添加和删除的原因

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `哈希冲突的解决办法`

1使用单链表解决，相同值存在链表下一个节点。遍历链表找。java中使用的，1.8之后链表长度大于8增加了红黑树

2开放定址法：线行探查法、平方探查法、双散列函数探查法。缺点：删除元素的时候不能真的删除，会引起查找错误，只能做一个特殊标记。下个元素插入才能真正删除该元素。

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `java`
> 基本概念，面试常见题型

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `哈希表的实现原理`

1.8之前使用链表，后面使用红黑树

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `hashmap和hashtable区别还有原理`

hashmap基于哈希表实现，1.8之前使用拉链法，后链表长度大于等于 8 时会将链表转换为红黑树。加载因子默认0.75，当前元素个数大于数组长度乘以加载因子时扩容。
hashmap 对比table 可以插入键为 null 的 Entry。 的迭代器是 fail-fast 迭代器。 不能保证随着时间的推移 Map 中的元素次序是不变的。

table和 HashMap 类似，但它是线程安全的，使用 synchronized 来进行同步，它是遗留类，不应该去使用它，
而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `面向对象`
> 基本概念，面试常见题型

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `面向对象三大特性`

封装，抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，只保留一些对外的接口使其与外部发生联系。
用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

继承，继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

多态，编译时多态（方法的重载）和运行时多态（程序中定义的对象引用所指向的具体类型在运行期间才确定），运行时多态三个条件：
继承，覆盖（重写），向上转型

## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `工具(git, docker, 正则表达式等)`

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `git常用命令`

git checkout master切换到主分支 => git pull => 修改冲突 => git add . git commit -m 'merge' 提交到本地 => git checkout italy => git merge master =>
git push完成

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `git如何多人合作`

西欧fast开发实践，使用公司开发的工具进行二次开发。每次把主分支合并到自己的分支

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `什么是微服务`

是一种软件架构风格，将软件设计为一组小型服务的方法，它是以专注于单一责任与功能的小型功能区块为基础，
利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API 集相互通信。
每个服务都在自己的进程中运行并进行通信。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `Docker原理`

使用Linux的namespace（类似于JAVA的命名空间）和cgroup（controll （system resource） （for） （process）groups），

namespace提供一种资源隔离方案（运行环境隔离），不同用户看不到其他用户资源。每个ns都有init进程(PID为0)（像一台单独的Linux）

cgroup用控制使用系统资源，防止占用过多，可以为ns分配资源

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `docker和虚拟机区别`

docker使用Linux内核，Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。
虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。虚拟机更擅长于彻底隔离整个运行环境。
虚拟机使用虚拟机管理系统（Hypervisor）。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `docker简单命令`

从镜像库拉去pull镜像，获得rabbimq。run启动，后面start/stop/restart，控制容器生命周期。rm删除容器。ps显示容器状态（-a显示所有），logs查询日志。

本地镜像管理：build创建（根据dockerfile）rmi删除镜像，images显示本地所有镜像。history展示镜像创建历史。


## ![#f03c15](https://placehold.it/15/f03c15/000000?text=+) `基于微服务的自动防御相关内容`

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `项目介绍`

项目包括CA（control app）控制系统 和 IDS (Intrusion Detection System) 入侵检测系统。
控制系统包括3个微服务，IDS我开发了3个微服务，并且对后续微服务需要的消息做了发布。
整个项目使用了7个docker 容器，部署了包括6个微服务和rabbitmq消息队列。还有一个模拟工厂水罐传感器信号的并发py脚本。传递实时水位情况。
自己写了转化类成为可以序列化和反序列化的变量（字典），涉及的类添加这个方法。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `为啥用nameko`

目前python下面主要都是web框架。是基于微服务架构理念的一个开源框架，框架的目的是让开发者更多的聚焦在业务逻辑和功能的实现上，而底层的通信机制则由框架本身来解决。
Django和Flask都是web后端，相比较这些框架提供的功能更多，但是使用也更复杂。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `nameko框架讲一下`

基于AMQP的RPC方式；
基于AMQP的异步事件发布-订阅；我使用的方式
简单的HTTP请求，GET和POST；
使用nameko需要使用RabbitMQ消息代理

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `为什么用rabbitmq（如何选择消息队列）对比不同消息队列`

Kafka是基于一套自己定义TCP协议的。由于选择了nameko使用AMQP协议，所以选择rabbitmq用做消息队列。开源提供的管理界面非常棒，用起来很好用
性能较好，高并发；吞吐量到万级，MQ功能比较完备。健壮、稳定、易用、跨平台、支持多种语言、文档齐全；

### [rabbitmq保重不重复消费](https://blog.csdn.net/n950814abc/article/details/98320046) [面试题](https://juejin.im/post/6844903997489446919)

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `RabbitMQ可靠性传输的实现 （发送方，broker ， 接收方）三方；消息幂等性实现（用户发起多次重复请求保持结果和一次请求一致）`

幂等性，通俗点说，，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。

给传感器信号打时间戳不会重复消费传感器数据，如果连续传输2个传感器信号可能一样，打了不同时间戳对于控制系统并没有影响，控制系统计算出的操作是一致的。

结合业务思考如何实现：比如写入数据库，根据主键检查，有了就只更新不插入。如果写redis（是set）直接写就行。生产者生产时候加上id，消费者拿到id去hash表查下是否有。
如果消费过就不处理了。

### ![#1589F0](https://placehold.it/15/1589F0/000000?text=+) `AMQP协议底层`

高级消息队列协议（Advanced Message Queuing Protocol）
是面向消息中间件提供的开放的应用层协议，其设计目标是对于消息的排序、路由（包括点对点和订阅-发布）、保持可靠性、保证安全性。
AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样。
与先前的中间件标准（如Java消息服务）不同的是，JMS在特定的API接口层面和实现行为上进行了统一，而高级消息队列协议则关注于各种消息如何以字节流的形式进行传递。
因此，使用了符合协议实现的任意应用程序之间可以保持对消息的创建、传递。

## [面试所有资料](https://github.com/CyC2018/CS-Notes)
